- Acceleration
	- Blits and solid fill

  - XAA and the shadow buffer will not work together, because the
    shadow buffer updates in the block handler, so if we got any XAA
    calls in between, things would get messed up. 

    Current plan:
	- Add our own damage tracker that produces raw rectangles
	- Whenever it fires, submit the copy immediately

	- Wrap the necessary ops in such a way that the original
	  implementation gets called first. The original implementation
	  will use fb, which will produce damage, which will get
	  submitted.

	  If we decide to accelerate a particular operation, first set
          a flag that the immediately following damage event should not
	  result in spice protocol being sent. Ie., 

	  on_op:
		qxl->enable_copying = FALSE

		call original;

		send acceleration command

		qxl->enable_copying = TRUE

	  Note damage is added before the drawing hits the framebuffer, so
	  it will have to be stored, then cleared
		- in a block handler
		- before accelerating

	  Ie., 

	  on_op:
		clear damage
		disable damage reporting
		call original (this will generate unreported damage and paint to the shadow)
		submit command
		enable damage

	   It may be possible to use the shadow code if we added a
	   shadowReportNow() that would report any existing
	   damage. Ie., basically export shadowRedisplay()

    1. Get damage added, out of CreateScreenResources
    2. Make sure it works
    3. Submit copies and disable shadow
    4. Delete shadow
    5. Wrap some of the ops, or use XAA?

- Coding style fixes

- Better malloc() implementation
	- Take dmalloc() from the windows driver?
	- Put blocks in a tree?

- Submit cursor images

- Find out why it picks 8x6 rather than a reasonable mode
 - Possibly has to do with the timings it reports. RandR only
   allows 8x6 and 6x4.

- Only compile mmtest if glib is installed
	Or maybe just get rid of mmtest.c

-=-=-=-=-

Done:

Question:

- Note: when we set a mode, all allocated memory should be considered
  released.

- What is the "vram" PCI range used for? 

  As I read the Windows driver, it can be mapped with the ioctl
  VIDEO_MAP_VIDEO_MEMORY. In driver.c it is mapped as pdev->fb, but
  it is then never used for anything as far as I can tell.

  Does Windows itself use that ioctl, and if so, for what. The area
  is only 32K in size so it can't really be used for any realistic
  bitmaps.

    It's a required ioctl.  I believe it's needed for DGA-like things.
    I have no idea how the Windows driver manages syncing for that,
    but I think we can safely ignore it. [ajax]

- Hook up randr if it isn't already

- Garbage collection
	- Before every allocation?
	- When we run out of memory?
	- Whenever we overflow some fixed pool?

- Get rid of qxl_mem.h header; just use qxl.h

- Split out ring code into qxl_ring.c

- Don't keep the maps around that are just used in preinit
	(Is there any real reason to not just do the CheckDevice in ScreenInit?)
